set nocompatible

let $VIMHOME=expand("$HOME/.vim")

" include plug-ins by vundle plugin:
source $VIMHOME/vundle_config.vim

syntax on
colorscheme Mustang

" Behavior -------------------------------------------------------------------

set regexpengine=1
set hidden " restore history of buffer coming from background
set modeline
set clipboard=unnamed,unnamedplus
set ttimeoutlen=100  " decrease timeout for faster insert with 'O'
set ttyfast
set lazyredraw

" Input ----------------------------------------------------------------------

set nrformats-=octal " No octal number handling with C-a and C-x
set cpoptions=B$ " cw-like commands mark end with $ instead of deleting.
set tildeop
set backspace=2
set spelllang=de,en
set spell

" UI -------------------------------------------------------------------------

set antialias
set t_Co=256
set colorcolumn=81
set cursorline
set cursorcolumn
set noerrorbells
let &visualbell = has('mac')
set t_vb=
set scrolloff=3 " scroll three lines before window start / end
set showcmd
set ruler " show cursor position
set hlsearch " highlight search results
set incsearch " highlight search while entering search string

" Format ---------------------------------------------------------------------

set encoding=utf-8
set autoindent
set formatoptions+=j
set formatoptions-=o
set shiftround " When at 3 spaces and I hit >>, go to 4, not 5.
set lisp " '-' is a word character

" Completion -----------------------------------------------------------------

set wildmenu
set wildignore+=.DS_Store
set wildignore+=*.orig
set wildignore+=*.pyc
set wildignore+=*.o
set wildignore+=*.class
set wildignore+=.hg
set wildignore+=.git
set wildignore+=.svn
set wildignore+=tmp

" Completion menu also with omni completion
set completeopt=longest,menuone

" Status line ----------------------------------------------------------------

set statusline=%<%f\ %h%m%r\ %{SyntasticStatuslineFlag()}%=%-14.(%l,%c%V%)\ %P

augroup modedetection
  autocmd InsertEnter * hi statusline guibg=#bb1111
  autocmd InsertEnter * hi CursorLine guibg=#c9d9e9
  autocmd InsertEnter * hi CursorColumn guibg=#c9d9e9
  autocmd InsertLeave * hi statusline guibg=#8090a0
  autocmd InsertLeave * hi CursorLine guibg=#f6f6f6
  autocmd InsertLeave * hi CursorColumn guibg=#eaeaea
augroup END

" Filetype stuff -------------------------------------------------------------

filetype plugin on
filetype plugin indent on

function! s:SetHeaderFiletype()
  let file_no_extension=expand("%:p:r")
  if filereadable(file_no_extension . ".cpp")
    set filetype=cpp
  elseif filereadable(file_no_extension . ".c")
    set filetype=c
  elseif filereadable(file_no_extension . ".m")
    set filetype=objc
  else
    echom "no .cpp, .c or .m file found."
  endif
endfunction

augroup filetypedetect
  " This group is created by vim, so don't use 'autocmd!'.
  autocmd BufRead,BufNewFile *.m set filetype=objc
  autocmd BufRead,BufNewFile *.h call s:SetHeaderFiletype()

  " Add html FileType for djangohtml files, to activate some html specific
  " plugins, like SnipeMate-Completion on htmldjango files.
  autocmd FileType htmldjango set ft=htmldjango.html
augroup END

" GUI ------------------------------------------------------------------------

function! ComputerName()
  if has('mac')
    return substitute(system('scutil --get ComputerName'), "\n", "", "")
  else
    return hostname()
  endif
endfunction

if has("gui_running")
  colorscheme pyte
  set number
  set guioptions='iecrL'
  set columns=88
  set laststatus=2

  augroup gui_stuff
    autocmd!
    autocmd GUIEnter * set guitablabel=%N\ %M%t
  augroup end

  if ComputerName() ==# 'macmini'
    set guifont=Monaco:h13
    set lines=55
  elseif ComputerName() ==# 'janneke'
    set guifont=Menlo:h14
    winpos 653 22
    set lines=63
  elseif ComputerName() ==# 'Maik Brendlers MacBook Pro'
    set guifont=Menlo:h15
    set lines=63
  elseif ComputerName() ==# 'atom'
    set guifont=Monospace\ 9.5
    winpos 298 16
    augroup gui_size
      autocmd!
      autocmd GUIEnter * set lines=37 columns=88
    augroup END
    set nocursorline
    set nocursorcolumn
  endif
endif

" rename current file, via Gary Bernhardt
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'))
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction

" Mappings -------------------------------------------------------------------

let mapleader = ","
nnoremap <Leader>n :TlistClose<CR>:NERDTreeToggle<CR>
nnoremap <Leader>m :TlistClose<CR>:NERDTreeFind<CR>
nnoremap <Leader>ü :NERDTreeClose<CR>:TlistToggle<CR>
nnoremap <Leader>k :SrcExplToggle<CR>
nnoremap <Leader>b :LustyBufferExplorer<CR>
nnoremap <Leader>t :CtrlP<CR>
nnoremap <Leader>r :call RenameFile()<CR>
nnoremap <Leader>f :call fullscreen#Toggle()<CR>
nnoremap <Leader># :execute "leftabove split " . bufname("#")<CR>
" nnoremap <Leader>w :match Error /\v\s+$/<cr>
" nnoremap <Leader>W :match none<cr>
nnoremap <Leader><C-w> :%s/\s\+$//g<cr>

nnoremap <Leader>cc :call ChangeWord('ToCamelCaseLower')<CR>
nnoremap <Leader>cC :call ChangeWord('ToCamelCaseUpper')<CR>
nnoremap <Leader>cs :call ChangeWord('ToSnakeCaseLower')<CR>
nnoremap <Leader>cS :call ChangeWord('ToSnakeCaseUpper')<CR>
nnoremap <Leader>cm :call ChangeWord('ToMinusCase')<CR>

nnoremap <Leader>ev :split $MYVIMRC<CR>
nnoremap <Leader>sv :source $MYVIMRC<CR>
let $FT_DIR = expand("$VIMHOME/after/ftplugin/")
nnoremap <Leader>ef :execute "split " . $FT_DIR . &filetype . ".vim"<CR>
nnoremap <Leader>sf :execute "source " . $FT_DIR . &filetype . ".vim"<CR>
nnoremap <Leader>eh :split $HOME/.hgrc<CR>
nnoremap <Leader>eg :split $HOME/.gitconfig<CR>
nnoremap <Leader>es :execute "split $HOME/.vim/snippets/" . &filetype . ".snippets"<CR>
nnoremap <Leader>ee :e %<CR>

noremap <Leader>m1 :call Tmux_select_window("1")<CR>
noremap <Leader>m2 :call Tmux_select_window("2")<CR>
noremap <Leader>m3 :call Tmux_select_window("3")<CR>
noremap <Leader>m4 :call Tmux_select_window("4")<CR>
noremap <Leader>m5 :call Tmux_select_window("5")<CR>
noremap <Leader>m6 :call Tmux_select_window("6")<CR>
noremap <Leader>m7 :call Tmux_select_window("7")<CR>
noremap <Leader>m8 :call Tmux_select_window("8")<CR>
noremap <Leader>m9 :call Tmux_select_window("9")<CR>
noremap <Leader>m0 :call Tmux_select_window("0")<CR>
noremap <Leader>mh :call Tmux_previous_window()<CR>
noremap <Leader>ml :call Tmux_next_window()<CR>
noremap <Leader>m<Enter> :call Tmux_send_key("C-m")<CR>
noremap <Leader>mm :call Tmux_send_key("C-m")<CR>
noremap <Leader>m<C-u> :call Tmux_send_key("C-u")<CR>
noremap <Leader>m<C-d> :call Tmux_send_key("C-d")<CR>
noremap <Leader>ms :call Tmux_send_text("hg st \|\| git status\n")<CR>
vnoremap <Leader>mm "ry :call Tmux_send_text(@r)<CR>
vnoremap <C-c><C-c> "ry :call Tmux_send_text(@r)<CR>

let maplocalleader = "ö"

augroup filetype_mappings
  autocmd!
  autocmd FileType c,objc,cpp,javascript nnoremap <buffer> <LocalLeader>; :execute "normal! mqA;\e`q"<cr>
augroup END

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" Insert new line without entering insert mode.
nnoremap <S-Enter> O<Esc>j
nnoremap <C-Enter> o<Esc>k

onoremap in( :<c-u>normal! f(vi(<cr>
onoremap il( :<c-u>normal! F)vi(<cr>
onoremap in{ :<c-u>normal! f{vi{<cr>
onoremap il{ :<c-u>normal! F}vi{<cr>
onoremap in[ :<c-u>normal! f[vi[<cr>
onoremap il[ :<c-u>normal! F]vi[<cr>
onoremap in< :<c-u>normal! f<vi<<cr>
onoremap il< :<c-u>normal! F>vi<<cr>

nnoremap ü <C-]>
nnoremap Ü <C-O>

" C-X C-G: relative version of file completions
let g:old_cwd = getcwd()
augroup file_completion_end
  autocmd!
  autocmd CompleteDone * execute "lcd " . g:old_cwd
augroup END
function! s:relative_completion()
  let g:old_cwd = getcwd()
  lcd %:p:h
  call feedkeys("a\<C-X>\<C-F>")
endfunction
inoremap <C-X><C-G> <esc>:call <SID>relative_completion()<cr>

" inoremap <left> <nop>
" inoremap <down> <nop>
" inoremap <up> <nop>
" inoremap <right> <nop>
" noremap <left> <nop>
" noremap <down> <nop>
" noremap <up> <nop>
" noremap <right> <nop>


" Commands -------------------------------------------------------------------

command! W w
command! Wq wq

command! Now :normal a<C-R>="".strftime('%H:%M %d.%m.%Y')<CR><Esc>
command! Today :normal a<C-R>="".strftime('%d.%m.%Y')<CR><Esc>

function! s:big_font()
  let g:gui_font = &guifont
  let g:win_pos_x = getwinposx()
  let g:win_pos_y = getwinposy()
  let g:lines = &lines
  let g:columns = &columns
  set guifont=Menlo:h24
endfunction
function! s:normal_font()
  if exists('g:gui_font')
    let &guifont=g:gui_font
    let &lines=g:lines
    let &columns=g:columns
    execute "winpos " . g:win_pos_x . " " . g:win_pos_y
  endif
endfunction

command! Big :call <SID>big_font()
command! Normal :call <SID>normal_font()

" Highlighting ---------------------------------------------------------------

" highlight trailing whitespace
highlight ExtraWhitespace ctermbg=1 guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Plugin Settings ------------------------------------------------------------

let NERDTreeIgnore = ['\.pyc$', '\.orig$']

let g:syntastic_ruby_checkers = ['mri', 'rubocop']
" let g:syntastic_stl_format = "%E{E:%e} %W{W:%w}"
let g:syntastic_cpp_compiler = "clang++"

" clang_complete
"" TODO: make this more standard
let LLVM_PREFIX = expand("$HOME/privateroot/opt/llvm/BD2/Release+Asserts/")
if isdirectory(LLVM_PREFIX . "/lib/")
  let g:clang_use_library = 1
  let g:clang_library_path = expand(LLVM_PREFIX . "/lib/")
endif
let g:clang_use_library = 1
let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/"

" Python
let g:jedi#popup_on_dot = 0
let g:jedi#goto_assignments_command = "<localleader>g"
let g:jedi#goto_definitions_command = "<localleader>d"
let g:jedi#documentation_command = "K"
let g:jedi#usages_command = "<localleader>n"
let g:jedi#completions_command = "<C-Space>"
let g:jedi#rename_command = "<localleader>r"
let g:jedi#show_call_signatures = "1"

" Ruby
let g:ruby_path="/usr/bin/ruby"

" Haskell-Mode
let g:haddock_browser = "open"
let g:haddock_browser_callformat = "%s %s"
let g:haddock_indexfiledir = "$HOME/.vim/"

" Tag list
let Tlist_Use_Right_Window = 1
let Tlist_Inc_Winwidth = 1
let Tlist_Enable_Fold_Column = 0
let Tlist_Display_Prototype = 0
let Tlist_Display_Tag_Scope = 0

" Find and load local vimrc --------------------------------------------------

let g:local_vimrc = fnamemodify(findfile('.vimrc', ';'), ':p')
if strlen(g:local_vimrc) != 0 && expand('~/.vimrc') != g:local_vimrc
  execute "source " . g:local_vimrc
endif
