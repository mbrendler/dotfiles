" ----------------------------------------------------------------------------

let g:python3_host_prog = '/usr/local/bin/python3'

if strlen(findfile('Pipfile', ';')) != 0
  let g:python_venv_dir = substitute(system('pipenv --venv 2> /dev/null'), '\n\+$', '', '')
  let $PYTHONPATH = g:python_venv_dir . '/lib/python3.7/site-packages'
  let $MYPYPATH = g:python_venv_dir . '/lib/python3.7/site-packages'
endif

let $VIMHOME=expand("$HOME/.vim")
let $FT_DIR=expand("$VIMHOME/after/ftplugin/")
let $MANPAGER=""

set nocompatible

" Extend runtimepath with plugin directories ---------------------------------

function! ExtendRuntimepath()
  for plugin_path in split(globpath(expand('~/.usr/plugins/vim'), '*'))
    if 0 != isdirectory(plugin_path) && -1 == match(&runtimepath, plugin_path)
      execute 'set runtimepath+=' . plugin_path
      let l:after_path = plugin_path . '/after'
      if isdirectory(l:after_path)
        execute 'set runtimepath+=' . l:after_path
      endif
    endif
  endfor
endfunction

call ExtendRuntimepath()

" Highlighting ---------------------------------------------------------------

syntax on
if hostname() == 'atom'
  colorscheme mbr-dark
else
  colorscheme mbr-light
endif

""" highlight trailing whitespace
highlight ExtraWhitespace ctermbg=1 guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter,InsertEnter,InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Behavior -------------------------------------------------------------------

set regexpengine=1 " improves performance with highlighting ruby files
set hidden " restore history of buffer coming from background
set nomodeline
set clipboard=unnamed,unnamedplus
set ttimeoutlen=100  " decrease timeout for faster insert with 'O'
set ttyfast
set lazyredraw
set shell=~/.zsh/run_script_with_zshrc
set nofoldenable

" Input ----------------------------------------------------------------------

set nrformats-=octal " No octal number handling with C-a and C-x
set cpoptions=B$ " cw-like commands mark end with $ instead of deleting.
set tildeop
set backspace=2
set spelllang=de,en
set nospell
set mouse=n

" UI -------------------------------------------------------------------------

set t_Co=256
set colorcolumn=81
set cursorline
set cursorcolumn
set noerrorbells
let &visualbell = has('mac')
set t_vb=
set scrolloff=3 " scroll three lines before window start / end
set showcmd
set ruler " show cursor position
set hlsearch " highlight search results
set incsearch " highlight search while entering search string
set display=lastline " display parts of the last line
set listchars=tab:‚Üí¬†
set list

" Format ---------------------------------------------------------------------

set encoding=utf-8
set autoindent
set formatoptions+=j
set formatoptions-=o
set shiftround " When at 3 spaces and I hit >>, go to 4, not 5.
set lisp " '-' is a word character
set expandtab
set shiftwidth=2
set softtabstop=2

" Completion -----------------------------------------------------------------

set wildmenu
set wildignore+=.DS_Store
set wildignore+=*.orig
set wildignore+=*.pyc
set wildignore+=*.o
set wildignore+=*.class
set wildignore+=.hg
set wildignore+=.git
set wildignore+=.svn
set wildignore+=tmp
set wildignore+=.beam

" Completion menu also with omni completion
set completeopt=longest,menuone

if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

" Functions ------------------------------------------------------------------

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', old_name)
  if new_name != '' && new_name != old_name
    if system('git ls-files ' . old_name) == ""
      execute ':saveas ' . new_name
      execute ':silent !rm ' . old_name
      redraw!
    else
      call system('git mv ' . old_name . ' ' . new_name . ' 2> /dev/null')
      execute 'edit ' . new_name
    endif
    execute 'bd ' . old_name
  endif
endfunction

function! SetCHeaderFiletype()
  let file_no_extension=expand("%:p:r")
  if filereadable(file_no_extension . ".cpp")
    set filetype=cpp
  elseif filereadable(file_no_extension . ".c")
    set filetype=c
  elseif filereadable(file_no_extension . ".m")
    set filetype=objc
  endif
endfunction

function! SourceLocalVimrc()
  let local_vimrc = findfile('.vimrc', ';')
  if local_vimrc != "" && expand('~/.vimrc') != fnamemodify(local_vimrc, ':p')
    execute "source " . fnamemodify(local_vimrc, ':p')
  endif
endfunction

function! VisualSelection()
  try
    let a_save = @a
    normal! gv"ay
    return @a
  finally
    let @a = a_save
  endtry
endfunction

function! GetBufferList()
  redir =>buflist
  silent! ls
  redir END
  return split(buflist, '\n')
endfunction

function! ToggleLocations()
  if empty(filter(GetBufferList(), 'v:val =~ "Location List"'))
    ALELint
    lopen
  else
    lclose
  endif
endfunction

function! CloseHiddenBuffers()
  let visible = {}
  for t in range(1, tabpagenr('$'))
    for b in tabpagebuflist(t)
      let visible[b] = 1
    endfor
  endfor
  for b in range(1, bufnr('$'))
    if bufloaded(b) && !has_key(visible, b)
      execute 'bd ' . b
    endif
  endfor
endfun

" Filetype stuff -------------------------------------------------------------

filetype plugin on
filetype plugin indent on

augroup filetypedetect
  " This group is created by Vim, so don't use 'autocmd!'.

  autocmd BufRead,BufNewFile *.m set filetype=objc
  autocmd BufRead,BufNewFile *.h call SetCHeaderFiletype()

  " Add html FileType for djangohtml files, to activate some html specific
  " plugins, like SnipeMate-Completion on htmldjango files.
  autocmd FileType htmldjango set filetype=htmldjango.html
augroup END

" Mappings -------------------------------------------------------------------

let mapleader = ","

nnoremap <Leader>n :TagbarClose<CR>:NERDTreeFind<CR>
nnoremap <Leader>N :TagbarClose<CR>:NERDTreeToggle<CR>
nnoremap <Leader>√º :NERDTreeClose<CR>:TagbarToggle<CR>
nnoremap <Leader>b :CtrlPBuffer<CR>
nnoremap <Leader>t :CtrlP<CR>
nnoremap <Leader>T :CtrlPTag<CR>
nnoremap <Leader>r :call RenameFile()<CR>
nnoremap <Leader># :CtrlPFindAlternatives<cr>
nnoremap <Leader>' :rightbelow vsplit #<CR>
nnoremap <Leader><C-w> :%s/\s\+$//g<cr>

nnoremap <Leader>cc :call ChangeWord('ToCamelCaseLower')<CR>
nnoremap <Leader>cC :call ChangeWord('ToCamelCaseUpper')<CR>
nnoremap <Leader>cs :call ChangeWord('ToSnakeCaseLower')<CR>
nnoremap <Leader>cS :call ChangeWord('ToSnakeCaseUpper')<CR>
nnoremap <Leader>cm :call ChangeWord('ToMinusCase')<CR>

nnoremap <Leader>ev :split $MYVIMRC<CR>
nnoremap <Leader>sv :source $MYVIMRC<CR>
nnoremap <Leader>ef :execute "split " . $FT_DIR . &filetype . ".vim"<CR>
nnoremap <Leader>sf :execute "source " . $FT_DIR . &filetype . ".vim"<CR>
nnoremap <Leader>ss :e .scratch<CR>
nnoremap <Leader>sS :split .scratch<CR>
nnoremap <Leader>st :tabnew .scratch<CR>
nnoremap <Leader>eh :split $HOME/.hgrc<CR>
nnoremap <Leader>eg :split $HOME/.gitconfig<CR>
nnoremap <Leader>es :execute "split $HOME/.vim/snippets/" . &filetype . ".snippets"<CR>
nnoremap <Leader>ee :e %<CR>

nnoremap <Leader>l :call ToggleLocations()<cr>
nnoremap <Leader>L :lclose<CR>

nnoremap <Leader>ml :call Tmux_run_command("")<CR>
nnoremap <Leader>ms :call Tmux_run_command("git status 2>/dev/null \|\| hg st 2>/dev/null")<CR>
nnoremap <Leader>md :call Tmux_run_command("git diff 2>/dev/null \|\| hg diff 2>/dev/null")<CR>
nnoremap <Leader>mD :call Tmux_run_command("git diff '" . expand('%') . "' 2>/dev/null")<CR>

nnoremap <leader>M  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>

let maplocalleader = "√∂"

nnoremap <LocalLeader>; :execute "normal! mqA;\e`q"<cr>
nnoremap <LocalLeader>rr :call Save_buffer_if_modified()<cr>:call Run_file(expand('%'))<cr>
nnoremap <LocalLeader>ri :call Save_buffer_if_modified()<cr>:call Run_interactive_file(expand('%'))<cr>
nnoremap <LocalLeader>f :ALEFix<cr>

""" Split line (sister to [J]oin lines)
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

""" Insert new line without entering insert mode.
nnoremap <S-Enter> O<Esc>j
nnoremap <C-Enter> o<Esc>k
nnoremap ¬± O<Esc>j
nnoremap Ô£ø o<Esc>k

nnoremap j gj
nnoremap k gk

nnoremap √º ]
nnoremap √§ [
" nnoremap √ú <C-]>
nnoremap √ú :ALEGoToDefinition<cr>
nnoremap g√∂ g]
vnoremap g√∂ g]

nnoremap g√º :call tgrep#find_tag(expand("<cword>"))<CR>
vnoremap g√º :call tgrep#find_tag(VisualSelection())<CR>

nnoremap K :call Rtfm(expand("<cword>"))<CR>
vnoremap K :call Rtfm(VisualSelection())<CR>

let g:no_man_maps = 1
autocmd BufEnter * if &readonly | nnoremap <buffer> q :q<cr> | endif

""" Vim-Tmux-Navigator mappings
let g:tmux_navigator_no_mappings = 0
if has('nvim')
  nnoremap <silent> <M-h> :TmuxNavigateLeft<cr>
  nnoremap <silent> <M-j> :TmuxNavigateDown<cr>
  nnoremap <silent> <M-k> :TmuxNavigateUp<cr>
  nnoremap <silent> <M-l> :TmuxNavigateRight<cr>
else
  nnoremap <silent> <ESC>h :TmuxNavigateLeft<cr>
  nnoremap <silent> <ESC>j :TmuxNavigateDown<cr>
  nnoremap <silent> <ESC>k :TmuxNavigateUp<cr>
  nnoremap <silent> <ESC>l :TmuxNavigateRight<cr>
endif

""" C-X C-G: relative version of file completions (C-X X-F)
let g:old_cwd = '.'
augroup file_completion_end
  autocmd!
  autocmd CompleteDone * execute "lcd " . g:old_cwd
augroup END
function! RelativeCompletion()
  let g:old_cwd = getcwd()
  lcd %:p:h
  call feedkeys("a\<C-X>\<C-F>")
endfunction
inoremap <C-X><C-G> <esc>:call RelativeCompletion()<cr>

inoremap <C-X><√º> <C-X><C-]>

nnoremap <C-_> <esc>:call Tmux_select_target_pane()<cr>

onoremap in( :<c-u>normal! f(vi(<cr>
onoremap il( :<c-u>normal! F)vi(<cr>
onoremap in{ :<c-u>normal! f{vi{<cr>
onoremap il{ :<c-u>normal! F}vi{<cr>
onoremap in[ :<c-u>normal! f[vi[<cr>
onoremap il[ :<c-u>normal! F]vi[<cr>
onoremap in< :<c-u>normal! f<vi<<cr>
onoremap il< :<c-u>normal! F>vi<<cr>

" Commands -------------------------------------------------------------------

command! W w
command! Wq wq

command! Now :normal a<C-R>=strftime('%Y-%m-%dT%H:%M')<CR><Esc>
command! Today :normal a<C-R>=strftime('%Y-%m-%d')<CR><Esc>

command! CtrlPFindAlternatives call ctrlp#find_alternatives#start(expand("%"))

command! -nargs=+ -complete=shellcmd Rtfm :call Rtfm("<args>")

" Status line ----------------------------------------------------------------

highlight User1 ctermfg=7 ctermbg=1 cterm=italic,bold

function! LinterStatus() abort
    let l:counts = ale#statusline#Count(bufnr(''))
    if l:counts.total == 0
      return ""
    else
      let l:all_errors = l:counts.error + l:counts.style_error
      let l:all_non_errors = l:counts.total - l:all_errors
      return printf(' W:%d,E:%d ', all_non_errors, all_errors)
    end
endfunction

set statusline=%<%f\ %h%m%r\ %1*%{LinterStatus()}%*\ %{tagbar#currenttag('%s','','f')}%=%-14.(%l,%c%V%)\ %P

set laststatus=2  " always show status line

" Plugin Settings ------------------------------------------------------------

if !exists('g:loaded_matchit')
  runtime macros/matchit.vim
endif

let NERDTreeIgnore = ['\.pyc$', '\.orig$']

let g:ctrlp_extensions = ['find_alternatives']
let g:ctrlp_buffer_func = { 'enter': 'CtrlPMappings' }

function! CtrlPMappings()
  nnoremap <buffer> <silent> <C-@> :call <sid>DeleteBuffer()<cr>
endfunction

function! s:DeleteBuffer()
  let path = fnamemodify(getline('.')[2:], ':p')
  let bufn = matchstr(path, '\v\d+\ze\*No Name')
  exec "bd" bufn ==# "" ? path : bufn
  exec "norm \<F5>"
endfunction

""" ALE
let g:ale_echo_msg_format = '%s [%linter%]'
let g:ale_sign_error = 'E'
let g:ale_sign_warning = 'W'
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_enter = 0
let g:ale_completion_enabled = 0

let g:ale_linters = {
\ 'python': ['pyls', 'mypy'],
\}

let g:ale_fixers = {
\ 'javascript': ['eslint'],
\ 'python': ['yapf'],
\ 'ruby': ['rubocop'],
\}

""" Neomake
" function! NeomakeLoadFile()
"   if filereadable('.clang_complete')
"     let g:neomake_cpp_clang_args = readfile('.clang_complete')
"     let g:neomake_c_clang_args = g:neomake_cpp_clang_args
"   endif
" endfunction
"
" " autocmd! BufWritePost * call NeomakeLoadFile() | Neomake
" let g:neomake_place_signs=1
" let g:neomake_cpp_enable_markers = ['clang++']
" let g:neomake_cpp_clang_args = ["-fsyntax-only", "-std=c++14", "-Wall", "-Wextra", "-Wpedantic"]
" let g:neomake_c_enable_markers = ['clang']
" let g:neomake_c_clang_args = ["-fsyntax-only", "-Wall", "-Wextra", "-Wpedantic"]
"
" let g:neomake_typescript_enabled_makers = ['tsuquyomi', 'tslint']
" let g:neomake_javascript_eslint_exe = getcwd() . '/node_modules/.bin/eslint'
" let g:neomake_javascript_enabled_makers = ['eslint', 'flow']
"
" let g:neomake_python_flake8_exe = 'python3'
" let g:neomake_python_enabled_makers = ['flake8']

""" TComment
let g:tcomment_mapleader1 = ""

""" tagbar
let g:tagbar_autofocus = 1
let g:tagbar_compact = 1
let g:tagbar_singleclick = 1

""" clang_complete
let g:clang_complete_auto = 0
let g:clang_use_library = 1
if has('mac')
  let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/"
endif
let g:clang_snippets = 1  " complete with arguments
let g:clang_snippets_engine = 'clang_complete'

""" Ruby
" let g:rubycomplete_buffer_loading = 1
" let g:rubycomplete_classes_in_global = 1
" let g:rubycomplete_rails = 1
let g:ruby_indent_block_style = 'do'
let g:ruby_indent_assignment_style = 'variable'

""" Python
let g:jedi#popup_on_dot = 0
let g:jedi#goto_assignments_command = "<localleader>g"
let g:jedi#goto_definitions_command = "<localleader>d"
let g:jedi#documentation_command = "K"
let g:jedi#usages_command = "<localleader>n"
let g:jedi#completions_command = "<C-X><C-O>"
let g:jedi#rename_command = "<localleader>r"
let g:jedi#show_call_signatures = 0

""" Haskell-Mode
let g:haddock_browser = "open"
let g:haddock_browser_callformat = "%s %s"
let g:haddock_indexfiledir = "$HOME/.vim/"

""" Typescript
let g:tsuquyomi_disable_default_mappings = 1
let g:tsuquyomi_disable_quickfix = 1

""" Tag list
let Tlist_Use_Right_Window = 1
let Tlist_Inc_Winwidth = 1
let Tlist_Enable_Fold_Column = 0
let Tlist_Display_Prototype = 0
let Tlist_Display_Tag_Scope = 0

" Find and load local .vimrc -------------------------------------------------

if ! has("gui_running")
  call SourceLocalVimrc()
endif
